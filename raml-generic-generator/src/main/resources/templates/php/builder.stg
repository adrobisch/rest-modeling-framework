import "generic.stg"

/*
 * implementation template functions
 */
updateBuilder(vendorName, builder)::=<<
\<?php
<generatorInfo()>

namespace <vendorName>\\Builder;

use <vendorName>\Base\BaseBuilder;
use <vendorName>\Exception\InvalidArgumentException;
<useTypeImport(vendorName, builder.baseActionType.import)>
<builder.typeImports: {ti |<useTypeImport(vendorName, ti)>}>

class <builder.resourceType.name>UpdateBuilder extends BaseBuilder {
    /**
     * @var <builder.resourceType.typeName>
     */
    private $resource = null;

    /**
     * @var array
     */
    private $actions = [];

    private $requestBuilderCallback;

    public function __construct(callable $requestBuilderCallback = null)
    {
        $this->requestBuilderCallback = $requestBuilderCallback;
    }

    <builder.updates: {u |<update(u)>}>

    /**
     * @param <builder.baseActionType.name> $action
     * @return $this;
     */
    public function addAction(<builder.baseActionType.name> $action)
    {
        $this->actions[] = $action;
        return $this;
    }

    private function resolveAction($class, $action = null)
    {
        if (is_null($action) || is_callable($action)) {
            $callback = $action;
            $emptyAction = $this->mapData($class, null);
            $action = $this->callback($emptyAction, $callback);
        }
        if ($action instanceof $class) {
            return $action;
        }

        throw new InvalidArgumentException(
            sprintf('Expected method to be called with or callable to return %s', $class)
        );
    }


    /*
     * @param $action
     * @param callable $callback
     */
    private function callback($action, callable $callback = null) {
        if (!is_null($callback)) {
            $action = $callback($action);
        }
        return $action;
    }

    /**
     * @param <builder.resourceType.typeName> $<builder.resourceType.typeName; format="lowercamel">
     * @return $this
     */
    public function with(<builder.resourceType.typeName> $<builder.resourceType.typeName; format="lowercamel">)
    {
        $this->resource = $<builder.resourceType.typeName; format="lowercamel">;
        return $this;
    }

    public function reset()
    {
        $this->actions = [];
        $this->resource = null;
    }

    public function getResource(): ?<builder.resourceType.typeName>
    {
        return $this->resource;
    }

    /**
     * Build <builder.updateType.typeName>
     * @return <builder.updateType.typeName>
     */
    public function build(): <builder.updateType.typeName>
    {
        $data = [
            'actions' => $this->actions,
        ];
        $update = $this->mapData(<builder.updateType.typeName>::class, $data);
        if ($update instanceof <builder.updateType.typeName> &&
            $this->resource instanceof <builder.resourceType.typeName>
        ) {
            $update->setVersion($this->resource->getVersion());
        }

        return $update;
    }

    public function buildRequest(): ?<builder.request.name>
    {
        if (!is_null($this->requestBuilderCallback)) {
            $callback = $this->requestBuilderCallback;
            return $callback($this);
        }

        return null;
    }
}

>>

update(action)::=<<

/**
 * @param <action.typeName>|callable $action builder function \<code\>
 *   function(<action.typeName> $action): <action.typeName> {
 *     // modify action as needed
 *     return $action;
 *   }
 *   \</code\>
 * @return $this
 */
public function <action.discriminatorValue>($action = null)
{
    $this->addAction($this->resolveAction(<action.typeName>::class, $action));
    return $this;
}
>>

actionBuilder(vendorName, type)::=<<
\<?php
<generatorInfo()>

namespace <vendorName>\\Builder;

use  <vendorName>\Base\BaseBuilder;
<type.typeImports: {ti |<useTypeImport(vendorName, ti)>}>

class <type.name>Builder extends BaseBuilder {
}
>>

builderTest(vendorName, builder) ::=<<
\<?php
<generatorInfo()>

namespace <vendorName>\\Builder;

use <vendorName>\\Builder\\<builder.resourceType.name>UpdateBuilder;
use <vendorName>\\Exception\\InvalidArgumentException;
<builder.typeImports: {ti |<useTypeImport(vendorName, ti)>}>
<builder.updateImports: {ti |<useTypeImport(vendorName, ti, "Model")>}>
use PHPUnit\\Framework\\TestCase;
<useTypeImport(vendorName, builder.resourceType.import, "Model")>

class <builder.resourceType.name>BuilderTest extends TestCase {
    <builder.updates: {action |<updateTest(builder, action)>}>

    public function testReset() {
        $builder = new <builder.resourceType.name>UpdateBuilder();
        $builder-><first(builder.updates).discriminatorValue>(new <first(builder.updates).typeName>Model());
        $update = $builder->build();
        static::assertInstanceOf(<builder.updateType.typeName>::class, $update);
        static::assertInstanceOf(<first(builder.updates).typeName>::class, $update->getActions()->current());

        $builder->reset();
        $update = $builder->build();
        static::assertInstanceOf(<builder.updateType.typeName>::class, $update);
        static::assertCount(0, $update->getActions());
    }

    public function testWithResource() {
        $builder = new <builder.resourceType.name>UpdateBuilder();
        static::assertNull($builder->getResource());

        $builder->with(new <builder.resourceType.typeName>Model());
        static::assertInstanceOf(<builder.resourceType.typeName>::class, $builder->getResource());
    }

    public function testBuild() {
        $builder = new <builder.resourceType.name>UpdateBuilder();
        $builder->with(new <builder.resourceType.typeName>Model(['version' => 3]));

        $update = $builder->build();
        static::assertInstanceOf(<builder.updateType.typeName>::class, $update);
        static::assertSame(3, $update->getVersion());
    }
}

>>

updateTest(builder, action) ::=<<

public function test<action.discriminatorValue; format="uppercamel">Callback() {
    $builder = new <builder.resourceType.name>UpdateBuilder();
    $builder-><action.discriminatorValue>(function($action) { static::assertInstanceOf(<action.typeName>::class, $action); return $action; });
    $update = $builder->build();
    static::assertInstanceOf(<builder.updateType.typeName>::class, $update);
    static::assertInstanceOf(<action.typeName>::class, $update->getActions()->current());
}

public function test<action.discriminatorValue; format="uppercamel">InvalidCallback() {
    $this->expectException(InvalidArgumentException::class);
    $builder = new <builder.resourceType.name>UpdateBuilder();
    $builder-><action.discriminatorValue>(function($action) { static::assertInstanceOf(<action.typeName>::class, $action); return []; });
}

public function test<action.discriminatorValue; format="uppercamel">Instance() {
    $builder = new <builder.resourceType.name>UpdateBuilder();
    $builder-><action.discriminatorValue>(new <action.typeName>Model());
    $update = $builder->build();
    static::assertInstanceOf(<builder.updateType.typeName>::class, $update);
    static::assertInstanceOf(<action.typeName>::class, $update->getActions()->current());
}

public function test<action.discriminatorValue; format="uppercamel">InvalidInstance() {
    $this->expectException(InvalidArgumentException::class);
    $builder = new <builder.resourceType.name>UpdateBuilder();
    $builder-><action.discriminatorValue>([]);
}

>>
