import "generic.stg"

interface(vendorName, type) ::= <<
\<?php
<generatorInfo()>

namespace <vendorName>\\<type.package.parts; separator="\\">;

<if(type.hasBuiltinParent)>
use <vendorName>\\Base\\JsonObject;

<endif>
<type.typeImports: {ti |<useTypeImport(vendorName, ti)>}>
interface <type.name> extends <if(!type.hasBuiltinParent)><type.parent.name><else>JsonObject<endif>
{
    <if(type.discriminator)>
    const DISCRIMINATOR = '<type.discriminator>';
    const SUB_TYPES = [
        <type.subTypes: {t |<discriminatorMapping(t)>}>
    ];

    <endif>
    <type.typeProperties: {p |<propertyConstant(p)>}>
    <type.patternProperties: {p |<propertyConstant(p)>}>
    <type.nonPatternProperties: {p |<propertyInterfaceGet(p)>}>
    <type.nonPatternProperties: {p |<propertyInterfaceSet(p)>}>
    <type.unionProperties: {p |<propertyInterfaceGetAs(type, p)>}>
    <if(type.hasPatternProperties)>
    public function get(string $key);
    public function set(string $key, $value);
    <endif>
    <if(type.updateType)>
    /**
     * @return <type.updateType.name>Builder
     */
    public function update();
    <endif>
}

>>

mapInterface(vendorName, type) ::= <<
\<?php
<generatorInfo()>

namespace <vendorName>\\<type.package.parts; separator="\\">;

use <vendorName>\\Base\\Map;

interface <type.name> extends Map
{
    /**
     * @param $key
     * @return <type.valueType.typeName>
     */
    public function get($key);

    /**
     * @param $data
     * @param $index
     * @return <type.valueType.typeName>
     */
    public function map($data, $index);
    <if(type.valueType.identifiers)>

    <type.valueType.identifiers: {id |<indexGetter(type, id)>}>
    <endif>
}

>>

indexGetter(type, identifier) ::=<<

/**
 * @param <identifier.type.name> $<identifier.name>
 * @return <type.valueType.typeName>
 */
public function by<identifier.name; format="capitalize">($<identifier.name>);
>>

discriminatorMapping(type) ::= <<
'<type.discriminatorValue>' => <if(type.package.hasPackage)><type.package.parts; separator="\\">\\<endif><type.name>::class,

>>

propertyConstant(property) ::=<<
const <property.constantName> = '<property.name>';

>>

propertyInterfaceGetAs(objectType, property) ::= <<
<property.unionGetters: {getter |<propertyInterfaceGetAsType(objectType, getter, getter.type)>}>
>>

propertyInterfaceGetAsType(objectType, getter, type) ::= <<

/**
 * @return <type.typeName>
 */
public function get<getter.property.name; format="capitalize">As<if(type.name)><type.name; format="uppercamel"><else><type.typeName; format="uppercamel"><endif>();

>>


propertyInterfaceGet(property) ::= <<

/**
 * @return <property.type.typeName>
 */
public function get<property.name; format="capitalize">();

>>

propertyInterfaceSet(property) ::= <<

/**
 * @param <property.type.typeName> $<property.name>
 * @return $this
 */
public function set<property.name; format="capitalize">(<if(property.setter.paramType)><property.setter.paramType> <endif>$<property.name>);

>>
