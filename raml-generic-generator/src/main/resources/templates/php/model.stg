import "generic.stg"

/*
 * implementation template functions
 */
model(vendorName, type) ::= <<
\<?php
<generatorInfo()>

namespace <vendorName>\\<type.package.parts; separator="\\">;

use <vendorName>\\Exception\\InvalidArgumentException;
<if(type.hasBuiltinParent)>
use <vendorName>\\Base\\JsonObjectModel;

<else>
<useTypeImport(vendorName, type.parent.import, "Model")>
<endif>
<type.typeImports: {ti |<useTypeImport(vendorName, ti)>}>
class <type.name>Model extends <if(!type.hasBuiltinParent)><type.parent.name>Model<else>JsonObjectModel<endif> implements <type.name>
{
    <if(type.discriminator || type.discriminatorValue)>
    const DISCRIMINATOR_VALUE = '<type.discriminatorValue>';

    <endif>
    <if(type.patternProperties)>
    private $patternData = [];
    <endif>
    <if(type.discriminator)>
    /**
     * @param array $data
     */
    public function __construct(array $data = []) {
        parent::__construct($data);
        $this->set<type.discriminator; format="capitalize">(static::DISCRIMINATOR_VALUE);
    }

    <endif>
    <type.nonPatternProperties: {p |<property(p)>}>
    <type.nonPatternProperties: {p |<getter(type, p)>}>
    <type.nonPatternProperties: {p |<(p.setter.setter)(p)>}>
    <type.unionProperties: {p |<propertyInterfaceGetAs(type, p)>}>
    <if(type.patternProperties)>
    <patternGetter(type, type.patternProperties)>
    <patternSetter(type, type.patternProperties)>
    <endif>
    <if(type.serializers)>

    public function jsonSerialize() {
        $data = parent::jsonSerialize();
        <type.serializers: {s|<(s.serializer)(type, s.property, s.format)>}>
        return $data;
    }
    <endif>
    <if(type.updateType)>

    /**
     * @return <type.updateType.name>Builder
     */
    public function update()
    {
        $builder = new <type.updateType.name>Builder();
        $builder->setMapper($this->getMapper());
        $builder->with($this);
        return $builder;
    }
    <endif>
    <if(type.patternProperties)>

    private function validKey(string $key): bool
    {
        switch (true) {
            <type.patternProperties: {p |<patternValid(type, p)>}>
            default:
                return false;
        }
    }

    /**
     * @inheritdoc
     */
    protected function toArray(): array
    {
        $data = parent::toArray();
        $data = array_merge($data, $this->patternData);
        unset($data['patternData']);
        return $data;
    }
    <endif>
}

>>

propertyInterfaceGetAs(objectType, property) ::= <<
<property.unionGetters: {getter |<propertyInterfaceGetAsType(objectType, getter, getter.type)>}>
>>

propertyInterfaceGetAsType(objectType, getter, type) ::= <<

/**
 * @return <type.typeName>
 */
public function get<getter.property.name; format="capitalize">As<if(type.name)><type.name; format="uppercamel"><else><type.typeName; format="uppercamel"><endif>()
{
    if (is_null($this-><getter.property.name>)) {
        <(getter.getter)(type, getter, {<objectType.name>::<getter.property.constantName>})>
        $this-><getter.property.name> = $value;
    }
    return $this-><getter.property.name>;
}

>>


patternGetter(type, properties) ::= <<
/**
 * @param string $key
 * @return mixed
 */
public function get(string $key)
{
    if (!isset($this->patternData[$key])) {
        switch (true) {
            <type.patternProperties: {p |<patternGet(type, p)>}>
            default:
                throw new InvalidArgumentException();
        }
        $this->patternData[$key] = $value;
    }
    return $this->patternData[$key];
}

>>

patternGet(type, property) ::= <<
case preg_match('<property.name>', $key) === 1:
    <(property.getter.getter)(type, p.getter, "$key")>
    break;
>>

patternSetter(type, properties) ::= <<
/**
 * @param string $key
 * @param mixed $value
 * @return $this
 */
public function set(string $key, $value)
{
    if (!$this->validKey($key)) {
        throw new InvalidArgumentException();
    }
    $this->patternData[$key] = $value;
    return $this;
}

>>

patternValid(type, property) ::= <<
case preg_match('<property.name>', $key) === 1:
    return true;
>>

getter(type, property) ::=<<
/**
 * @return <property.type.typeName>
 */
public function get<property.name; format="capitalize">()
{
    if (is_null($this-><property.name>)) {
        <(property.getter.getter)(type, property.getter, {<type.name>::<property.constantName>})>
        $this-><property.name> = $value;
    }
    return $this-><property.name>;
}

>>

defaultGetter(type, getter, get) ::= <<
$value = $this->raw(<get>);
>>

dateTimeGetter(type, getter, get) ::= <<
$value = $this->raw(<get>);
<if(getter.format)>
$dateTime = \DateTimeImmutable::createFromFormat('<getter.format>', $value);
$value = $dateTime ? $dateTime : null;
<else>
$value = new \DateTimeImmutable($value);
<endif>
>>

scalarGetter(type, getter, get) ::= <<
$value = $this->raw(<get>);
$value = (<getter.format>)$value;
>>

classGetter(type, getter, get) ::= <<
$value = $this->raw(<get>);
<if(getter.type.discriminator)>
$resolvedClass = $this->resolveDiscriminator(<getter.type.name>::class, $value);
if (is_null($value)) {
    return $this->mapData($resolvedClass, null);
}
$value = $this->mapData($resolvedClass, $value);
<else>
if (is_null($value)) {
    return $this->mapData(<getter.type.name>::class, null);
}
$value = $this->mapData(<getter.type.name>::class, $value);
<endif>
>>

arrayGetter(type, getter, get) ::= <<
$value = $this->raw(<get>);
if (is_null($value)) {
    return $this->mapData(<getter.type.typeName>::class, null);
}
$value = $this->mapData(<getter.type.typeName>::class, $value);
>>

defaultSetter(property) ::= <<
/**
 * @param $<property.name>
 * @return $this
 */
public function set<property.name; format="capitalize">(<if(property.setter.paramType)><property.setter.paramType> <endif>$<property.name>)
{
    $this-><property.name> = $<property.name>;

    return $this;
}

>>

dateTimeSetter(property) ::= <<
/**
 * @param \DateTimeImmutable|\DateTime|string $<property.name>
 * @return $this
 */
public function set<property.name; format="capitalize">(<if(property.setter.paramType)><property.setter.paramType> <endif>$<property.name>)
{
    if ($<property.name> instanceof \DateTime) {
        $<property.name> = \DateTimeImmutable::createFromMutable($<property.name>);
    }
    if (!$<property.name> instanceof \DateTimeImmutable) {
        $<property.name> = new \DateTimeImmutable($<property.name>);
    }
    $this->$<property.name> = $<property.name>;

    return $this;
}

>>

scalarSetter(property) ::= <<
/**
 * @param <property.type.typeName> $<property.name>
 * @return $this
 */
public function set<property.name; format="capitalize">(<if(property.setter.paramType)><property.setter.paramType> <endif>$<property.name>)
{
    $this-><property.name> = (<property.type.typeName>)$<property.name>;

    return $this;
}

>>

classSetter(property) ::= <<
/**
 * @param <if(property.setter.docType)><property.setter.docType><else>mixed<endif> $<property.name>
 * @return $this
 */
public function set<property.name; format="capitalize">(<if(property.setter.paramType)><property.setter.paramType> <endif>$<property.name>)
{
    <if(property.setter.paramCheck)>
    if (!$<property.name> instanceof <property.setter.docType>) {
        throw new InvalidArgumentException();
    }
    <endif>
    $this-><property.name> = $<property.name>;

    return $this;
}

>>

arraySetter(property) ::= <<
/**
 * @param <if(property.setter.paramCheck)><property.setter.docType><else><if(property.type.typeName)><property.type.typeName><else>mixed<endif><endif> $<property.name>
 * @return $this
 */
public function set<property.name; format="capitalize">(<if(property.setter.paramType)><property.setter.paramType> <endif>$<property.name>)
{
    <if(property.setter.paramCheck)>
    if (!$<property.name> instanceof <property.setter.docType>) {
        throw new InvalidArgumentException();
    }
    <endif>
    $this-><property.name> = $<property.name>;

    return $this;
}

>>

property(property) ::= <<
/**
 * @var <property.type.typeName>
 */
protected $<property.name>;

>>

timeSerializer(type, property, dateTimeFormat) ::= <<

if (isset($data[<type.name>::<property.constantName>]) && $data[<type.name>::<property.constantName>] instanceof \DateTimeImmutable) {
    $data[<type.name>::<property.constantName>] = $data[<type.name>::<property.constantName>]->format('<dateTimeFormat>');
}
>>

dateSerializer(type, property, dateTimeFormat) ::= <<

if (isset($data[<type.name>::<property.constantName>]) && $data[<type.name>::<property.constantName>] instanceof \DateTimeImmutable) {
    $data[<type.name>::<property.constantName>] = $data[<type.name>::<property.constantName>]->format('<dateTimeFormat>');
}
>>

dateTimeSerializer(type, property, dateTimeFormat) ::= <<

if (isset($data[<type.name>::<property.constantName>]) && $data[<type.name>::<property.constantName>] instanceof \DateTimeImmutable) {
    $data[<type.name>::<property.constantName>] = $data[<type.name>::<property.constantName>]->setTimeZone(new \DateTimeZone('UTC'))->format('<dateTimeFormat>');
}
>>


mapModel(vendorName, type) ::= <<
\<?php
<generatorInfo()>

namespace <vendorName>\\<type.package.parts; separator="\\">;

use <vendorName>\\Base\\JsonMap;
use <vendorName>\\Exception\\InvalidArgumentException;

class <type.name>Model extends JsonMap implements <type.name>
{

    /**
     * @param $data
     * @param $index
     * @return <type.valueType.typeName>
     */
    public function map($data, $index)
    {
        <(type.mapper.getter)(type, type.mapper)>
        return $data;
    }
    <if(type.valueType.identifiers)>

    protected function index($data)
    {
        foreach ($data as $key => $value) {
            <type.valueType.identifiers: {id |<index(id)>}>
        }
    }

    <type.valueType.identifiers: {id |<indexGetter(type, id)>}>
    <endif>
}

>>

index(identifier) ::=<<

if (isset($value['<identifier.name>'])) {
    $this->addToIndex('<identifier.name>', $value['<identifier.name>'], $key);
}
>>

indexGetter(type, identifier) ::=<<

/**
 * @param <identifier.type.name> $<identifier.name>
 * @return <type.valueType.name>
 */
public function by<identifier.name; format="capitalize">($<identifier.name>)
{
    return $this->valueByKey('<identifier.name>', $<identifier.name>);
}
>>

defaultMapper(type, mapper) ::= <<
>>

dateTimeMapper(type, mapper) ::= <<
if (!is_null($data) && !$data instanceof \DateTimeImmutable) {
    <if(mapper.format)>
    $dateTime = \DateTimeImmutable::createFromFormat('<mapper.format>', $data);
    $data = $dateTime ? $dateTime : null;
    <else>
    $data = new \DateTimeImmutable($value);
    <endif>
    $this->rawSet($data, $index);
}
>>

scalarMapper(type, mapper) ::= <<
if (!is_null($data)) {
    $data = (<mapper.format>)$data;
    $this->rawSet($data, $index);
}
>>

classMapper(type, mapper) ::= <<
if (!is_null($data) && !$data instanceof <type.valueType.name>) {
    <if(type.valueType.discriminator)>
    $resolvedClass = $this->resolveDiscriminator(<type.valueType.name>::class, $data);
    $data = $this->mapData($resolvedClass, $data);
    <else>
    $data = $this->mapData(<type.valueType.name>::class, $data);
    <endif>
    $this->rawSet($data, $index);
}
>>
