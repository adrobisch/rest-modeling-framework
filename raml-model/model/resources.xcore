@Ecore(nsPrefix="resources",nsURI="http://www.vrap.io/raml/resources")
@GenModel(modelDirectory="/raml-model/src/main/java-gen",
    complianceLevel="8.0")
package io.vrap.rmf.raml.model.resources

import java.util.Map

import org.eclipse.emf.ecore.EDiagnosticChain
import org.eclipse.emf.ecore.EMap
import org.eclipse.emf.common.util.Diagnostic
import org.eclipse.emf.common.util.BasicDiagnostic

import io.vrap.rmf.raml.model.facets.ProtocolsFacet

import io.vrap.rmf.raml.model.elements.DocumentableElement

import io.vrap.rmf.raml.model.types.AnnotationsFacet
import io.vrap.rmf.raml.model.types.HeadersFacet
import io.vrap.rmf.raml.model.types.QueryParametersFacet
import io.vrap.rmf.raml.model.types.TypedElement

import io.vrap.rmf.raml.model.security.SecuredByFacet
import io.vrap.rmf.raml.model.elements.IdentifiableElement

import io.vrap.rmf.raml.model.responses.BodyContainer
import io.vrap.rmf.raml.model.responses.ResponsesFacet
import io.vrap.rmf.raml.model.facets.Instance

class UriTemplate {
	contains UriTemplatePart[] parts	
	
	op String toString() {
		parts.join("")
	}
	
	/*
	 * Converts this uri template to a string where the variables
	 * are replaced with the given params.
	 */
	op String toString(Parameters params) {
		parts.map[it.toString(params)].join("")
	}
}

type Parameters wraps Map<String, Object>

interface UriTemplatePart {
	/*
	 * Converts this uri template part to a string where the variables
	 * are replaced with the given params.
	 */
	op String toString(Parameters params)
}

class UriTemplateLiteral extends UriTemplatePart {
	String literal	
	
	op String toString() {
		literal
	} 
	
	op String toString(Parameters params) {
		toString
	}
}

class UriTemplateExpression extends UriTemplatePart {
	String operator
	String[] variables
	
	op String toString() {
		val opStr = if (operator === null) "" else operator
		"{" + opStr  + variables.join(",") + "}"
	} 	
	
	op String toString(Parameters params) {
		var result = ""
		for (String varName : variables) {
			result += params.get(varName)
		}
		result
	}
}

class UriParameter extends TypedElement {
}

interface ResourceContainer {
	/*
	 * The (sub-) resources that this element contains. 
	 */
	contains Resource[] resources
}

/*
 * The commonalities between {@link Resource} and {@link ResourceType}
 */
interface ResourceBase extends DocumentableElement, AnnotationsFacet, SecuredByFacet, ApplyTraitsFacet {
	/*
	 * The uri parameters of this resource.
	 */
	contains UriParameter[] uriParameters
	
	/*
	 * The methods that this resource provides.
	 */
	contains Method[] methods
		
	/*
	 * The resource type that this resource inherits.
	 */
	contains ResourceTypeApplication ^type
	
	/*
	 * Returns the method with the given http method or null if
	 * no method with the given http method exists.
	 */
	op Method getMethod(HttpMethod httpMethod) {
		for (Method method : methods) {
			if (method.method == httpMethod) {
				return method
			}
		}
		return null
	}	
}


class ResourceTypeApplication {
	refers ResourceType ^type
	contains Parameter[] parameters 
}

class Resource extends ResourceBase, ResourceContainer, ApplyTraitsFacet {
	/*
	 * The relative uri of this resource.
	 */
	contains UriTemplate relativeUri
	
	@Ecore(invariant = "true")
	op boolean methodsMustBeRequired(EDiagnosticChain diagnostics,EMap<Object,Object> context) {
		val optionalMethods = methods.filter[!it.required].toList
		optionalMethods.forEach[diagnostics.add(new BasicDiagnostic(Diagnostic.ERROR, null, -1, 
			"Optional method not allowed in resource declaration " + it, null))]
		optionalMethods.isEmpty
	}
}

class ResourceType extends ResourceBase, IdentifiableElement {
	String usage
}

enum HttpMethod {
	^get 
	patch
	put
	post
	delete
	head
	options 
}

interface ApplyTraitsFacet {
	/*
	 * A list of the traits to apply to this element.
	 */
	contains TraitApplication[] is	
}

/*
 * The commonalities between {@link Method} and {@link Trait}
 */
interface MethodBase extends DocumentableElement, AnnotationsFacet, ProtocolsFacet, SecuredByFacet, 
					 HeadersFacet, QueryParametersFacet, ResponsesFacet, ApplyTraitsFacet, BodyContainer {
}
 
class Method extends MethodBase {
	/*
	 * The HTTP method.
	 */
	HttpMethod method
	
	/*
	 * Methods defined in a resource are always required,
	 * but methods defined in a resource type can be optional. 
	 */
	boolean required = "true"
				
	@Ecore(invariant="true")	
	op boolean hasValidProtocols(EDiagnosticChain diagnostics,EMap<Object,Object> context) {
		val invalidValues = protocols.map[it.toLowerCase].filter[it != 'http' && it != 'https']
		invalidValues.forEach[diagnostics.add(new BasicDiagnostic(Diagnostic.ERROR, null, -1, "Invalid protocol " + it, null))]
		invalidValues.empty
	}
}

class Trait extends IdentifiableElement, MethodBase {
	String usage
}

class Parameter {
	String name
	contains Instance value
}

class TraitApplication {
	refers Trait trait
	contains Parameter[] parameters 
}