@Ecore(nsPrefix="types",nsURI="http://www.vrap.io/raml/annotations")
@GenModel(
    modelDirectory="/raml-model/src/main/java-gen",
    complianceLevel="8.0"
)
package io.vrap.rmf.raml.model.annotations

import io.vrap.rmf.raml.model.elements.DocumentableElement
import io.vrap.rmf.raml.model.elements.IdentifiableElement
import io.vrap.rmf.raml.model.facets.ArrayTypeFacet
import io.vrap.rmf.raml.model.facets.DateTimeTypeFacet
import io.vrap.rmf.raml.model.facets.FileTypeFacet
import io.vrap.rmf.raml.model.facets.NumberTypeFacet
import io.vrap.rmf.raml.model.facets.ObjectTypeFacet
import io.vrap.rmf.raml.model.facets.Property
import io.vrap.rmf.raml.model.facets.StringTypeFacet

/*
 * The location within an API specification where annotations can be applied MUST be one of the target locations
 * in the following Target Locations table. The targets are the locations themselves, not sub-properties within the locations.
 * For example, the Method target refers to the method node, not to the method display name, description, and so on.
 */
enum AnnotationTarget {
	/*
	 * The root of a RAML document
	 */
	API,
	/*
	 * An item in the collection of items that is the value of the root-level documentation node.
	 */
	DocumentationItem,
	/*
	 * A resource (relative URI) node, root-level or nested
	 */
	Resource,
	/*
	 * A method node.
	 */
	Method,
	/*
	 * A declaration of the responses node, whose key is an HTTP status code.
	 */
	Response,
	/*
	 * The body node of a method.
	 */
	RequestBody,
	/*
	 * The body node of a response.
	 */
	ResponseBody,
	/*
	 * A data type declaration (inline or in a global type collection), header declaration,
	 * query parameter declaration, URI parameter declaration, or a property within any of these declarations,
	 * where the type property can be used.
	 */
	TypeDeclaration,
	/*
	 * Either an example or examples node
	 */
	Example,
	/*
	 * A resource type node.
	 */
	ResourceType,
	/*
	 * A trait node.
	 */
	Trait,
	/*
	 * A security scheme declaration.
	 */
	SecurityScheme,
	/*
	 * The settings node of a security scheme declaration
	 */
	SecuritySchemeSettings,
	/*
	 * A declaration of the annotationTypes node, whose key is a name of an annotation type and whose value describes the annotation.
	 */
	AnnotationType,
	/*
	 * The root of a library.
	 */
	Library,
	/*
	 * The root of an overlay.
	 */
	Overlay,
	/*
	 * The root of an extension.
	 */
	Extension
}


interface AnnotatedElement {
	/*
	 * The annotations of this element.
	 */
	contains Instance<?>[] annotations

	/*
	 * Returns the annotation of the given annotation type if it exists.
	 * Otherwise returns null.
	 */
	op <T extends AnyAnnotationType, A extends Instance<T>> A getAnnotation(T annotationType) {
		var a = annotations.findFirst[it.^type == annotationType]

		if (a != null) a as A else null
	}
}

/*
 * Annotation types are declared using the OPTIONAL root-level annotationTypes node.
 * The value of the annotationsType node is a map whose keys define annotation type names,
 * also referred to as annotations, and whose values are key-value pairs called annotation type declarations.
 * An annotation type declaration has the same syntax as a data type declaration,
 * and its facets have the same syntax as the corresponding ones for data types, but with the addition of the allowedTargets facet.
 * An annotation type declaration constrains the value of an annotation of that type just as a data type declaration constrains
 * the value of a URI parameter, query parameter, header, or body of that type.
 * The allowedTargets node restricts the kinds of locations where the annotation can be applied. Annotation types, like data types,
 * can extend other data types, but annotation types themselves can neither be extended nor used anywhere data types can be used.
 */
class AnyAnnotationType extends DocumentableElement, IdentifiableElement, AnnotatedElement {	
		/*
	 * The type which this type extends.
	 */
	refers AnyAnnotationType ^type
	
	/*
	 * The locations to which annotations are restricted.
	 * If this node is specified, annotations of this type may be applied only on a node corresponding to one of the locations.
	 */
	AnnotationTarget[] allowedTargets	
}

class TimeOnlyAnnotationType extends AnyAnnotationType {
}

class DateTimeAnnotationType extends DateTimeTypeFacet, AnyAnnotationType {
}

class DateTimeOnlyAnnotationType extends AnyAnnotationType {
}

class DateOnlyAnnotationType extends AnyAnnotationType {
}

class NumberAnnotationType extends NumberTypeFacet, AnyAnnotationType {
}

class IntegerAnnotationType extends NumberAnnotationType {
}

class BooleanAnnotationType extends AnyAnnotationType {	
}

class StringAnnotationType extends StringTypeFacet, AnyAnnotationType {	
}

class NilAnnotationType extends AnyAnnotationType {
}

class FileAnnotationType extends FileTypeFacet, AnyAnnotationType {	
}

class ObjectAnnotationType extends ObjectTypeFacet<AnyAnnotationType, Property<AnyAnnotationType>>, AnyAnnotationType {	
}

class ArrayAnnotationType extends ArrayTypeFacet<AnyAnnotationType>, AnyAnnotationType {
}


class Instance<T extends AnyAnnotationType> {
	refers T ^type
}

class StringInstance extends Instance<StringAnnotationType> {
	String value
}

class BooleanInstance extends Instance<BooleanAnnotationType> {
	Boolean value
}

class NumberInstance extends Instance<IntegerAnnotationType> {
	BigDecimal value
}

class IntegerInstance extends Instance<IntegerAnnotationType> {
	Long value
}

class ObjectInstance extends Instance<ObjectAnnotationType> {
	contains Instance<?>[] value

	/*
	 * Returns the property of the given type if it exists.
	 * Otherwise returns null.
	 */
	op <T extends AnyAnnotationType, V extends Instance<T>> V getPropertyy(T valueType) {
		var p = value.findFirst[it.^type == valueType]

		if (p != null) p as V else null
	}
}

